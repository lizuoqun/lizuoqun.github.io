import{_ as t,C as n,c as r,o as i,aP as l,G as e}from"./chunks/framework.BJOOWd-7.js";const k=JSON.parse('{"title":"02333 软件工程 ✒️","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"exam/02333.md","filePath":"exam/02333.md","lastUpdated":1754106726000}'),o={name:"exam/02333.md"};function h(d,a,p,g,c,u){const s=n("MarkTitle");return i(),r("div",null,[a[0]||(a[0]=l(`<h1 id="_02333-软件工程-✒️" tabindex="-1">02333 软件工程 ✒️ <a class="header-anchor" href="#_02333-软件工程-✒️" aria-label="Permalink to &quot;02333 软件工程 ✒️&quot;">​</a></h1><h2 id="绪论" tabindex="-1">绪论 <a class="header-anchor" href="#绪论" aria-label="Permalink to &quot;绪论&quot;">​</a></h2><h3 id="软件工程概念的提出与发展" tabindex="-1">软件工程概念的提出与发展 <a class="header-anchor" href="#软件工程概念的提出与发展" aria-label="Permalink to &quot;软件工程概念的提出与发展&quot;">​</a></h3><p>从事软件开发实践和软件工程项目管理的<strong>思想基础</strong>：正确认识软件开发</p><h4 id="软件危机" tabindex="-1">软件危机 <a class="header-anchor" href="#软件危机" aria-label="Permalink to &quot;软件危机&quot;">​</a></h4><p>20世纪60年代以来，随着计算机的广泛应用，软件生产率、软件质量满足不了社会发展的需求，成为社会、经济发展的<strong>制约因素</strong> ，人们通常把这些现象称为软件危机</p><h4 id="软件工程概念的提出" tabindex="-1">软件工程概念的提出 <a class="header-anchor" href="#软件工程概念的提出" aria-label="Permalink to &quot;软件工程概念的提出&quot;">​</a></h4><p>软件工程概念的提出，其目的是倡导<strong>以工程的原理、原则和方法</strong>进行软件开发以期解决出现的“软件危机&quot;</p><p>软件工程这一术语首次出现在<strong>1968</strong>年的 <strong>NATO（北大西洋公约组织）</strong> 会议上</p><h4 id="软件工程的定义" tabindex="-1">软件工程的定义 <a class="header-anchor" href="#软件工程的定义" aria-label="Permalink to &quot;软件工程的定义&quot;">​</a></h4><p>软件工程是应用<strong>计算机科学理论和技术以及工程管理原则和方法</strong>，按预算和进度实现满足用户要求的软件产品的<strong>工程</strong>，或以此为研究对象的 <strong>学科</strong></p><h4 id="软件工程的发展" tabindex="-1">软件工程的发展 <a class="header-anchor" href="#软件工程的发展" aria-label="Permalink to &quot;软件工程的发展&quot;">​</a></h4><p>20世纪60年代末到80年代初</p><ul><li>主要成果：提出<strong>瀑布模型</strong>，开发了诸多<strong>过程式语言</strong>（如c语言、Pascal语言）和<strong>开发方法</strong> （如Jackson方法、结构化方法）、开发了一些<strong>支持工具</strong>（调试工具、测试工具）等</li><li>特征：前期主要研究<strong>系统实现技术</strong>，后期开始关注<strong>软件质量和软件工程管理</strong></li></ul><p>20世纪80年代以来</p><ul><li>主要成果：提出 <strong>《软件生存周期过程》</strong>、开展<strong>计算机辅助工程（CASE）</strong>、<strong>面向对象语言</strong>（如Smalltalk、C++）、 提出<strong>面向对象软件开发方法</strong>等</li><li>特征：开展了一系列有关软件生产技术，特别是<strong>软件复用技术和软件生产管理</strong>的研究和实践</li></ul><h3 id="软件开发的本质" tabindex="-1">软件开发的本质 <a class="header-anchor" href="#软件开发的本质" aria-label="Permalink to &quot;软件开发的本质&quot;">​</a></h3><h4 id="计算机软件" tabindex="-1">计算机软件 <a class="header-anchor" href="#计算机软件" aria-label="Permalink to &quot;计算机软件&quot;">​</a></h4><p>一般是指计算机系统中的<strong>程序及其文档</strong></p><ul><li>程序是对计算机任务的<strong>处理对象和处理规则</strong>的描述</li><li>文档是为了理解程序所需的<strong>阐述性资料</strong></li></ul><h4 id="本质" tabindex="-1">本质 <a class="header-anchor" href="#本质" aria-label="Permalink to &quot;本质&quot;">​</a></h4><p>客户需求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> 具体实现</p><p>软件开发的目标是将<strong>问题域</strong>中的概念映射为<strong>运行平台</strong>层面上的概念，把问题域中的处理逻辑映射为运行平台层面上的处理逻辑</p><p>软件开发就是要弥补问题域与运行平台之间的<strong>距离</strong>，人从而在二者之间直接进行映射</p><h4 id="系统建模" tabindex="-1">系统建模 <a class="header-anchor" href="#系统建模" aria-label="Permalink to &quot;系统建模&quot;">​</a></h4><ul><li>概念：不同抽象层术语之间的<strong>映射</strong>，以及不同抽象层处理逻辑之间的<strong>映射</strong>，实现这一映射的基本途径</li><li>内容： <ul><li>一是如何<strong>实现</strong>这样的映射，这是技术层面的问题</li><li>二是如何<strong>管理</strong>这样的映射，以保障映射的有效性和正确性，这是管理层面的问题</li></ul></li></ul><h4 id="模型" tabindex="-1">模型 <a class="header-anchor" href="#模型" aria-label="Permalink to &quot;模型&quot;">​</a></h4><p>简单地说，是<strong>待建系统的任意抽象</strong>，其中包括所有的基本能力、特性或其他一些方面，而没有任何冗余的细节</p><p>进一步说，模型是在特定意图下所确定的角度和抽象层次上<strong>对物理系统的描述</strong>，通常包含对该系统边界的描述、对系统内各模型元素以及它们之间关系的语义描述</p><p>在软件开发中，软件系统模型大体上可分为两类：<strong>概念模型</strong>和<strong>软件模型</strong>。分层的<strong>基本动机</strong>是为了控制开发的复杂性</p><ul><li>在需求层上创建的系统<strong>概念模型</strong>是对客观事物系统的抽象即标识要解决的问题，或称问题定义</li><li>软件模型又可进一步分为<strong>设计模型、实现模型和部署模型</strong>等</li></ul><h2 id="软件需求及其规约" tabindex="-1">软件需求及其规约 <a class="header-anchor" href="#软件需求及其规约" aria-label="Permalink to &quot;软件需求及其规约&quot;">​</a></h2><h3 id="需求及其获取" tabindex="-1">需求及其获取 <a class="header-anchor" href="#需求及其获取" aria-label="Permalink to &quot;需求及其获取&quot;">​</a></h3><p>软件需求是任何软件工程项目的<strong>基础</strong>！</p><h4 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h4><p>一个需求描述了待开发产品、系统<strong>功能上的能力、性能参数或其他性质</strong></p><p>5个基本性质</p><ol><li>必要的：该需求是用户所要求的</li><li>无歧义的：该需求只能用一种方式解释</li><li>可测的：该需求是可进行测试的</li><li>可跟踪的：该需求可从一个开发阶段跟踪到另一个阶段</li><li>可测量的：该需求是可测量的</li></ol><h4 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h4><table tabindex="0"><thead><tr><th>需求分类</th><th>细分</th><th>描述</th></tr></thead><tbody><tr><td>功能需求</td><td></td><td>规约了系统或系统构件必须执行的能力，是整个需求的<strong>主体</strong></td></tr><tr><td>非功能需求</td><td>性能需求</td><td>规约了一个系统或构件在<strong>性能</strong>方面必须具有的一些特性</td></tr><tr><td></td><td>外部接口需求</td><td>规约了系统或构件<strong>必须与之交互</strong>的用户、硬件、软件或数据库元素<br>其中也可能规约交互格式、时间或其他因素</td></tr><tr><td></td><td>设计约束</td><td>限制了软件系统或构件的设计方案的<strong>范围</strong><br>需考虑<strong>法规政策</strong>、硬件限制等</td></tr><tr><td></td><td>质量属性</td><td>规约了软件产品所具有的一个性质（包括功能和其他需求）<br>必须达到其<strong>质量方面</strong>一个所<strong>期望</strong>的水平</td></tr></tbody></table><h4 id="需求发现技术" tabindex="-1">需求发现技术 <a class="header-anchor" href="#需求发现技术" aria-label="Permalink to &quot;需求发现技术&quot;">​</a></h4><ul><li>自悟：需求人员把自己<strong>作为系统的最终用户</strong>，审视该系统并提出问题：如果是我使用这一系统，则我需要...</li><li>交谈：为确定系统应该提供的功能，需求人员通过<strong>提出问题/用户回答</strong>这一方式，直接询问用户需要的是一个什么样的系统</li><li>观察：通过<strong>观察用户</strong>执行其现行的任务和过程，或通过观察他们如何操作与所期望的新系统有关的现有系统，了解系统运行的环境，特别是了解要建立的新系统与现存系统、过程以及工作方法间必须进行的交互</li><li>小组会：举行客户和开发人员的<strong>联席会议</strong>，与客户组织的一些代表共同开发需求</li><li>提炼：<strong>复审技术文档</strong>，并提取相关信息</li></ul><h3 id="需求规约" tabindex="-1">需求规约 <a class="header-anchor" href="#需求规约" aria-label="Permalink to &quot;需求规约&quot;">​</a></h3><h4 id="定义-1" tabindex="-1">定义 <a class="header-anchor" href="#定义-1" aria-label="Permalink to &quot;定义&quot;">​</a></h4><p>需求规约是一个软件产项/产品/系统<strong>所有需求陈述的正式文档</strong>，它表达了一个软件产项/产品/系统的概念模型</p><p>4个基本性质</p><ul><li>重要性和稳定性程度：按需求的重要性和稳定性对需求进行分级，如基本需求、可选需求和期望需求</li><li>可修改的：在不过多地影响其他需求的前提下，可以容易地修改一个单一需求</li><li>完整的：没有被遗漏的需求</li><li>一致的：不存在互斥的需求</li></ul><h4 id="格式" tabindex="-1">格式 <a class="header-anchor" href="#格式" aria-label="Permalink to &quot;格式&quot;">​</a></h4><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 引言</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   1.1 目的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   1.2 范围</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   1.3 定义，缩略语</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   1.4 参考文献</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   1.5 概述</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 总体描述</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   2.1 产品概述</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   2.2 产品功能</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   2.3 用户特性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   2.4 约束</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   2.5 假设和依赖</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 特定需求 【文档的技术核心】</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">附录</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">索引</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="表达" tabindex="-1">表达 <a class="header-anchor" href="#表达" aria-label="Permalink to &quot;表达&quot;">​</a></h4><ol><li>非形式化的需求规约： <ul><li>以一种<strong>自然语言</strong>来表达需求规约，如同使用一种自然语言写了一篇文章。适用于规模比较小的、复杂程度不大高的小型软件项目，或在获取SRS（草案）时使用的</li></ul></li><li>半形式化的需求规约： <ul><li>以<strong>半形式化符号体系</strong>（包括术语表、标准化的表达格式等）来表达需求规约，一些有能力的组织针对大型复杂项目，在开发需求文档时往往使用系统化的需求获取、分析技术和工具</li></ul></li><li>形式化的需求规约： <ul><li>以一种基于良构数学概念的符号体系来编制需求规约，一般常伴有解释性注释的支持，主要针对质量（特别是安全性）要求比较高的软件产品/系统或其中某一部分</li></ul></li></ol><h4 id="作用" tabindex="-1">作用 <a class="header-anchor" href="#作用" aria-label="Permalink to &quot;作用&quot;">​</a></h4><ul><li>需求规约是软件开发组织和用户之间一份事实上的<strong>技术合同书</strong>，是<strong>产品功能及其环境的体现</strong></li><li>对于项目的其余大多数工作，需求规约是一个<strong>管理控制点</strong></li><li>对于产品／系统的设计，需求规约是一个<strong>正式的、受控的起始点</strong></li><li>需求规约是创建产品验收测试计划和用户指南的基础，即基于需求规约一般还会产生另外两个文档—— <strong>初始测试计划和用户系统操作描述</strong></li></ul><h2 id="结构化方法" tabindex="-1">结构化方法 <a class="header-anchor" href="#结构化方法" aria-label="Permalink to &quot;结构化方法&quot;">​</a></h2><h2 id="面向对象方法-umi" tabindex="-1">面向对象方法 Umi <a class="header-anchor" href="#面向对象方法-umi" aria-label="Permalink to &quot;面向对象方法 Umi&quot;">​</a></h2><h2 id="面向对象方法-rup" tabindex="-1">面向对象方法 Rup <a class="header-anchor" href="#面向对象方法-rup" aria-label="Permalink to &quot;面向对象方法 Rup&quot;">​</a></h2><h2 id="软件测试" tabindex="-1">软件测试 <a class="header-anchor" href="#软件测试" aria-label="Permalink to &quot;软件测试&quot;">​</a></h2><h2 id="软件生命周期过程与管理" tabindex="-1">软件生命周期过程与管理 <a class="header-anchor" href="#软件生命周期过程与管理" aria-label="Permalink to &quot;软件生命周期过程与管理&quot;">​</a></h2><h2 id="集成化能力成熟度模型-cmmi" tabindex="-1">集成化能力成熟度模型 CMMI <a class="header-anchor" href="#集成化能力成熟度模型-cmmi" aria-label="Permalink to &quot;集成化能力成熟度模型 CMMI&quot;">​</a></h2><table tabindex="0"><thead><tr><th>题型</th><th>个数</th><th>分值</th><th>总分</th></tr></thead><tbody><tr><td>单选</td><td>15</td><td>2</td><td>30</td></tr><tr><td>填空</td><td>20</td><td>1</td><td>20</td></tr><tr><td>简答</td><td>6</td><td>5</td><td>30</td></tr><tr><td>综合应用</td><td>2</td><td>10</td><td>20</td></tr></tbody></table>`,60)),e(s,{color:"text-red-500",weight:"500"})])}const m=t(o,[["render",h]]);export{k as __pageData,m as default};
