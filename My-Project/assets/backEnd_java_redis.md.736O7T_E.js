import{_ as e,c as i,o as l,aP as r}from"./chunks/framework.DkXG5xPu.js";const b=JSON.parse('{"title":"Redis","description":"","frontmatter":{},"headers":[],"relativePath":"backEnd/java/redis.md","filePath":"backEnd/java/redis.md","lastUpdated":1750401273000}'),d={name:"backEnd/java/redis.md"};function t(o,a,s,h,n,c){return l(),i("div",null,a[0]||(a[0]=[r('<h1 id="redis" tabindex="-1">Redis <a class="header-anchor" href="#redis" aria-label="Permalink to &quot;Redis&quot;">​</a></h1><h2 id="缓存穿透" tabindex="-1">缓存穿透 <a class="header-anchor" href="#缓存穿透" aria-label="Permalink to &quot;缓存穿透&quot;">​</a></h2><p>在进行查询的时候，查询一条不存在的数据，这种方式就叫做缓存穿透，也就是一直查id为-1的数据，一直访问进行恶意攻击，缓存利用不大，请求大规模的涌向数据库，容易导致数据库宕机崩溃。</p><h2 id="缓存击穿" tabindex="-1">缓存击穿 <a class="header-anchor" href="#缓存击穿" aria-label="Permalink to &quot;缓存击穿&quot;">​</a></h2><p>指的是某一个热点key突然失效，导致很多请求直接访问数据库，导致数据库压力大</p><h2 id="缓存雪崩" tabindex="-1">缓存雪崩 <a class="header-anchor" href="#缓存雪崩" aria-label="Permalink to &quot;缓存雪崩&quot;">​</a></h2><p>缓存当中的大量失效，导致缓存雪崩，缓存雪崩时，大量请求都直接访问数据库，导致数据库压力大</p><h2 id="aof-rdb" tabindex="-1">AOF &amp; RDB <a class="header-anchor" href="#aof-rdb" aria-label="Permalink to &quot;AOF &amp; RDB&quot;">​</a></h2><ul><li>AOF <code>append only file</code> 只追加日志文件，将所有的写入操作记入到日志文件当中，当服务突然宕机之后，重启时只需要在执行一遍日志文件，这样数据还是会持久化回来</li><li>RDB <code>RedisDataBase</code> 在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储</li></ul><h2 id="redis-过期key清除策略" tabindex="-1">Redis 过期key清除策略 <a class="header-anchor" href="#redis-过期key清除策略" aria-label="Permalink to &quot;Redis 过期key清除策略&quot;">​</a></h2><ul><li>惰性过期 访问key时，判断key是否过期，如果过期则清除，如果没过期，则不清除</li><li>定时过期 每隔一段时间，对所有设置了过期时间的（expires）key进行扫描，判断是否过期，如果过期则清除，如果没过期，则不清除</li></ul><h2 id="redis-单线程快的原因" tabindex="-1">Redis 单线程快的原因 <a class="header-anchor" href="#redis-单线程快的原因" aria-label="Permalink to &quot;Redis 单线程快的原因&quot;">​</a></h2><ul><li>纯内存操作</li><li>基于非阻塞的IO多路复用模型</li><li>单线程反而避免了线程切换的开销</li></ul><h2 id="事务实现" tabindex="-1">事务实现 <a class="header-anchor" href="#事务实现" aria-label="Permalink to &quot;事务实现&quot;">​</a></h2><ul><li>MULTI 命令 -&gt; 事务开始 -&gt; 在客户端通过 <code>REDIS_MULTI</code> 标记</li><li>开启事务后 -&gt; 所有的命令都会加到事务队列当中</li><li>执行EXEC 命令 -&gt; 执行事务队列中的所有命令</li></ul><h2 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h2><ul><li>字符串 String kv结构，可以用来存储用户信息</li><li>哈希表 Hash 存字典数据</li><li>列表 List 有序队列</li><li>集合 Set 业务场景需要唯一</li><li>有序集合 zSet scope分数（排行榜） <ul><li>之前是压缩链表实现，高版本后转换成listPack</li></ul></li></ul><h2 id="redis-mysql-一致性问题" tabindex="-1">Redis &amp; MySQL 一致性问题 <a class="header-anchor" href="#redis-mysql-一致性问题" aria-label="Permalink to &quot;Redis &amp; MySQL 一致性问题&quot;">​</a></h2><ul><li>先删除Redis缓存，再更新MySQL数据库，再在查询时，更新缓存到Redis</li><li>延时双删：先删除Redis缓存，再更新MySQL数据库，延时几百毫秒后再删除Redis, 这样就算其他线程读取了MysQL数据库，把旧数据更新到Redis缓存，也会被其他线程删除</li></ul><h2 id="分布式锁底层原理" tabindex="-1">分布式锁底层原理 <a class="header-anchor" href="#分布式锁底层原理" aria-label="Permalink to &quot;分布式锁底层原理&quot;">​</a></h2><ul><li>利用<code>setnx</code>命令：如果key不存在才能获取到锁</li><li>利用lua脚本保证原子性</li><li>锁过期，通过定时任务监听是否需要续期</li><li>redis节点挂掉 需要采用红锁同时向 n/2+1 个节点申请锁，都获取到锁，才认为获取成功</li></ul><h2 id="看门狗机制" tabindex="-1">看门狗机制 <a class="header-anchor" href="#看门狗机制" aria-label="Permalink to &quot;看门狗机制&quot;">​</a></h2><p>看门狗机制是<code>redission</code>提供的一种自动延期机制，这个机制使得<code>redission</code>提供的分布式锁是可以自动续期的。</p>',23)]))}const k=e(d,[["render",t]]);export{b as __pageData,k as default};
