import{_ as k,C as t,c as e,o as r,aP as h,j as a,a as i,G as l,w as p}from"./chunks/framework.BJOOWd-7.js";const m=JSON.parse('{"title":"04737 C++ ☑️","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"exam/04737.md","filePath":"exam/04737.md","lastUpdated":1752215792000}'),E={name:"exam/04737.md"};function d(g,s,y,c,F,b){const n=t("font");return r(),e("div",null,[s[39]||(s[39]=h("",190)),a("p",null,[s[1]||(s[1]=i("在同一个作用域内，不能声明")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[0]||(s[0]=[i("同名")])),_:1,__:[0]}),s[2]||(s[2]=i("的标识符"))]),s[40]||(s[40]=a("p",null,"取代 namespace{int x,y} =》static int x,y;",-1)),s[41]||(s[41]=a("p",null,"常量对象在 C++遵循：可调用常量成员函数",-1)),s[42]||(s[42]=a("p",null,"存在整形 int x，int * p=a 与其他三项含义不同【int& p = a】【int & p = a】【int &p = 1】",-1)),a("p",null,[s[4]||(s[4]=i("静态局部变量具有局部作用域和")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[3]||(s[3]=[i("全局生存期")])),_:1,__:[3]})]),s[43]||(s[43]=a("h3",{id:"运算符重载-1",tabindex:"-1"},[i("运算符重载 "),a("a",{class:"header-anchor",href:"#运算符重载-1","aria-label":'Permalink to "运算符重载"'},"​")],-1)),a("p",null,[s[6]||(s[6]=i("运算符重载时，可以对运算符优先级、结合性进行重新定义（x）")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[5]||(s[5]=[i("不允许修改优先级和结合性")])),_:1,__:[5]})]),a("p",null,[s[8]||(s[8]=i("进行函数重载，新函数和已有函数的参数个数和类型完全相同，那么新函数必须用 ")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[7]||(s[7]=[i("const")])),_:1,__:[7]}),s[9]||(s[9]=i(" 修饰"))]),s[44]||(s[44]=a("p",null,"成员运算符比友元运算符少一个参数，这是因为成员函数具有this指针",-1)),s[45]||(s[45]=a("p",null,"++a 重载 operator++()",-1)),s[46]||(s[46]=a("h3",{id:"函数",tabindex:"-1"},[i("函数 "),a("a",{class:"header-anchor",href:"#函数","aria-label":'Permalink to "函数"'},"​")],-1)),a("p",null,[s[11]||(s[11]=i("只有类的成员函数才能访问类中的私有成员（x）")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[10]||(s[10]=[i("友元函数可以访问所有成员")])),_:1,__:[10]})]),a("p",null,[s[13]||(s[13]=i("void f()是类 A 的非静态成员函数，a 是类 A的对象，")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[12]||(s[12]=[i("a.f()可以写成 a.A::f()")])),_:1,__:[12]})]),s[47]||(s[47]=a("p",null,"空函数有函数体、函数体为空，纯虚函数没有函数体",-1)),s[48]||(s[48]=a("p",null,"析构函数可以定义为虚函数",-1)),a("p",null,[s[15]||(s[15]=i("不能作为函数重载的判断依据是")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[14]||(s[14]=[i("返回类型")])),_:1,__:[14]}),s[16]||(s[16]=i("，（const、参数个数、参数类型是可以的）"))]),s[49]||(s[49]=a("p",null,"虚函数只能是类中的一个成员函数，但不能是静态成员，关键字virtual用于类中该函数的声明中。一个类中可以说明多个纯虚函数",-1)),a("p",null,[s[18]||(s[18]=i("在类中定义和实现的函数可以成为")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[17]||(s[17]=[i("内联函数")])),_:1,__:[17]}),s[19]||(s[19]=i("，它能够加快程序执行速度【增加代码量】"))]),s[50]||(s[50]=a("p",null,'函数 v1(int v1)和 v2[]="ABCD"分别作为第一、二参数传给 f1，f1 的原型为 void f(int *a, char *b) =>f1(&v1,v2)',-1)),s[51]||(s[51]=a("p",null,"函数重载：参数类型不同、参数个数不同",-1)),s[52]||(s[52]=a("h3",{id:"类-1",tabindex:"-1"},[i("类 "),a("a",{class:"header-anchor",href:"#类-1","aria-label":'Permalink to "类"'},"​")],-1)),a("p",null,[s[21]||(s[21]=i("类 A 和 B，如果 A(B())可以通过编译：类 B 是类 A 的")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[20]||(s[20]=[i("派生类且定义了无参构造")])),_:1,__:[20]})]),a("p",null,[s[23]||(s[23]=i("类 A 的构造都是 protected ，类 B 以公有继承 A，则在 main()中 ")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[22]||(s[22]=[i("B b")])),_:1,__:[22]}),s[24]||(s[24]=i(" 正确"))]),a("p",null,[s[26]||(s[26]=i("定义在所有类和函数之外的变量具有")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[25]||(s[25]=[i("文件作用域")])),_:1,__:[25]})]),a("p",null,[s[28]||(s[28]=i("类的静态成员函数中不能使用 ")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[27]||(s[27]=[i("this ")])),_:1,__:[27]}),s[29]||(s[29]=i("指针"))]),s[53]||(s[53]=a("p",null,"对象可以有继承性，但并不是任何对象都必须有继承性",-1)),s[54]||(s[54]=a("p",null,"在未建立对象前，类的静态成员就已经存在",-1)),s[55]||(s[55]=a("p",null,"Test 类成员 static int x 初始化 int Test::x = 25",-1)),a("p",null,[s[31]||(s[31]=i("实现动态多态，除了继承之外必须使用")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[30]||(s[30]=[i("虚函数")])),_:1,__:[30]})]),a("p",null,[s[33]||(s[33]=i("用 private 修饰成员类，有利于隐藏程序的")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[32]||(s[32]=[i("实现细节")])),_:1,__:[32]})]),s[56]||(s[56]=h("",7)),a("p",null,[s[35]||(s[35]=i("模版的作用主要是")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[34]||(s[34]=[i("降低编码工作量")])),_:1,__:[34]})]),a("p",null,[s[37]||(s[37]=i("通过类模版可以实例化多个不同的类，这些类之间的关系是")),l(n,{style:{color:"#DF2A3F"}},{default:p(()=>s[36]||(s[36]=[i("相互独立")])),_:1,__:[36]}),s[38]||(s[38]=i("的"))]),s[57]||(s[57]=a("p",null,"模板函数的真正代码是在源程序中调用函数时产生",-1)),s[58]||(s[58]=a("p",null,"类模板和类不是同一层次的抽象",-1)),s[59]||(s[59]=a("p",null,[i("模版 "),a("code",null,"template<typename T>"),i("，T 在模版中不能作为函数模板名")],-1))])}const o=k(E,[["render",d]]);export{m as __pageData,o as default};
