import{_ as a,c as i,o as l,aP as e}from"./chunks/framework.BJOOWd-7.js";const p=JSON.parse('{"title":"css","description":"","frontmatter":{},"headers":[],"relativePath":"frontEnd/h5c3/css.md","filePath":"frontEnd/h5c3/css.md","lastUpdated":1755247002000}'),r={name:"frontEnd/h5c3/css.md"};function d(o,t,s,h,n,c){return l(),i("div",null,t[0]||(t[0]=[e('<h1 id="css" tabindex="-1">css <a class="header-anchor" href="#css" aria-label="Permalink to &quot;css&quot;">​</a></h1><h2 id="盒子模型" tabindex="-1">盒子模型 <a class="header-anchor" href="#盒子模型" aria-label="Permalink to &quot;盒子模型&quot;">​</a></h2><p>所有的标签都可以看成是一个盒子，盒子模型包括：content、padding、border、margin</p><h2 id="css选择器优先级" tabindex="-1">css选择器优先级 <a class="header-anchor" href="#css选择器优先级" aria-label="Permalink to &quot;css选择器优先级&quot;">​</a></h2><p>!import &gt; 行内 &gt; id &gt; class &gt; 标签 &gt; 全局</p><h2 id="隐藏元素" tabindex="-1">隐藏元素 <a class="header-anchor" href="#隐藏元素" aria-label="Permalink to &quot;隐藏元素&quot;">​</a></h2><ul><li>display: none;</li><li>visibility: hidden;</li><li>opacity: 0;</li><li>position: absolute;</li><li>clip-path: rect(0,0,0,0);</li></ul><h2 id="px-rem" tabindex="-1">px &amp; rem <a class="header-anchor" href="#px-rem" aria-label="Permalink to &quot;px &amp; rem&quot;">​</a></h2><ul><li>px 像素</li><li>rem 相对单位 基于根元素的字体大小</li></ul><h2 id="重绘-重排" tabindex="-1">重绘 &amp; 重排 <a class="header-anchor" href="#重绘-重排" aria-label="Permalink to &quot;重绘 &amp; 重排&quot;">​</a></h2><ul><li>重排（回流）：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小</li><li>重绘：计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制</li></ul><h2 id="水平垂直居中" tabindex="-1">水平垂直居中 <a class="header-anchor" href="#水平垂直居中" aria-label="Permalink to &quot;水平垂直居中&quot;">​</a></h2><ul><li>flex</li><li>position + margin</li><li>position + transform</li><li>grid</li><li>table</li></ul><h2 id="伪类-伪元素" tabindex="-1">伪类 &amp; 伪元素 <a class="header-anchor" href="#伪类-伪元素" aria-label="Permalink to &quot;伪类 &amp; 伪元素&quot;">​</a></h2><ul><li>伪类是指某个元素在处于某种状态下会添加的样式</li><li>伪元素是创建不在文档树里面的元素进行展示</li></ul><h2 id="css容器查询能否替代媒体查询" tabindex="-1">CSS容器查询能否替代媒体查询 <a class="header-anchor" href="#css容器查询能否替代媒体查询" aria-label="Permalink to &quot;CSS容器查询能否替代媒体查询&quot;">​</a></h2><ul><li>容器查询：允许你根据一个元素的容器宽度（或其他尺寸） 来应用样式，而不是根据整个视口（viewport）的尺寸</li><li>媒体查询：则是根据视口的尺寸来应用样式。</li></ul><table tabindex="0"><thead><tr><th>项目</th><th>媒体查询</th><th>容器查询</th></tr></thead><tbody><tr><td>依据</td><td>屏幕宽度</td><td>容器宽度</td></tr><tr><td>粒度</td><td>页面级</td><td>组件级</td></tr><tr><td>灵活性</td><td>低</td><td>高</td></tr><tr><td>可复用性</td><td>低（依赖上下文）</td><td>高（组件自包含）</td></tr><tr><td>未来趋势</td><td>基础能力</td><td>现代响应式核心</td></tr></tbody></table><p>不能完全替代</p><h2 id="响应式开发中如何避免窗口大小监听导致的重排抖动" tabindex="-1">响应式开发中如何避免窗口大小监听导致的重排抖动 <a class="header-anchor" href="#响应式开发中如何避免窗口大小监听导致的重排抖动" aria-label="Permalink to &quot;响应式开发中如何避免窗口大小监听导致的重排抖动&quot;">​</a></h2><ul><li>防抖节流：对窗口大小变化的监听事件进行节流或防抖处理</li><li>减少DOM操作：避免触发不必要的重排和重绘</li><li>CSS动画：对于一些需要动态调整的元素，可以使用 CSS 动画来实现平滑的过渡效果，而不是直接修改样式</li></ul>',21)]))}const m=a(r,[["render",d]]);export{p as __pageData,m as default};
