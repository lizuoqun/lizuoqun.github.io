import{_ as h,E as t,c as p,m as s,a as i,J as l,w as n,aS as e,o as k}from"./chunks/framework.Dn4syfiR.js";const ns=JSON.parse('{"title":"04735 数据库系统原理","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"exam/04735.md","filePath":"exam/04735.md","lastUpdated":1733816149000}'),r={name:"exam/04735.md"},d=e("",3),E=s("li",null,[i("数据库管理系统（DBMS），是专门用于建立和管理数据库的一套软件，介于应用程序和操作系统之间 "),s("ul",null,[s("li",null,"数据定义——提供数据定义语言（DDL），定义表、视图、存储过程、触发器等"),s("li",null,"数据操纵——提供数据操纵语言（DML）操纵数据库中的基本数据，包括查询、插入、删除和修改等"),s("li",null,"数据库的运行管理——保证数据库的安全性、完整性、多用户对数据的并发使用以及发生故障后的系统恢复"),s("li",null,"数据库的建立和维护——创建数据库、对数据库的空间维护、数据库的备份与恢复、数据库的重组织和性能监听、分析等"),s("li",null,"数据组织、存储和管理——例如：索引查找、顺序查找等"),s("li",null,"其他功能——主要包括与其他软件的网络通信功能、不同数据库管理系统之间的数据传输以及相互访问功能等")])],-1),c=e("",3),o=s("ul",null,[s("li",null,"DBMS提供子模式描述语言（Subschema DDL）来严格定义子模式")],-1),g=e("",6),u=e("",6),y=s("li",null,"层次模型",-1),b=s("li",null,"网状模型",-1),F=s("li",null,"面向对象模型",-1),m=e("",11),A={id:"关系数据语言的分类",tabindex:"-1"},_=s("a",{class:"header-anchor",href:"#关系数据语言的分类","aria-label":'Permalink to "**<font style="color:rgb(0,0,0);">关系数据语言的分类 </font>**"'},"​",-1),D=s("p",null,"关系操作分为代数方式和逻辑方式",-1),C=e("",5),q={id:"函数依赖与关键字",tabindex:"-1"},f=s("a",{class:"header-anchor",href:"#函数依赖与关键字","aria-label":'Permalink to "**<font style="color:rgb(0,0,0);">函数依赖与关键字</font>**"'},"​",-1),x=s("ul",null,[s("li",null,"设R为任一给定关系，如果对于R中属性X的每一个值，R中的属性Y都只有唯一值与之对应，则称X函数决定Y或称Y函数依赖于X，记作X→Y。其中X称为决定因素"),s("li",null,"完全函数依赖：设R为任一给定关系，X、Y为其属性集，若X →Y，且对X中的任何真子集X’都有X’ ↛Y，则称Y完全函数依赖于X"),s("li",null,"部分函数依赖：设R为任一给定关系，X、Y为其属性集，若X →Y，且X中存在一个真子集X’满足X’ → Y，则称Y部分函数依赖于X"),s("li",null,"传递函数依赖：设R为任一给定关系，X、Y、Z为其属性子集，若X →Y，Y ↛X，Y→Z，则有X →Z。称Z传递函数依赖于X"),s("li",null,"设R为任一给定关系，U为其所含的全部属性集合，X为U的子集，若有完全函数依赖X →U，则X为R的一个候选关键字")],-1),P={id:"范式与关系范式化",tabindex:"-1"},B=s("a",{class:"header-anchor",href:"#范式与关系范式化","aria-label":'Permalink to "**<font style="color:rgb(0,0,0);">范式与关系范式化</font>**"'},"​",-1),T=e("",4),v={id:"数据库设计的目标",tabindex:"-1"},S=s("a",{class:"header-anchor",href:"#数据库设计的目标","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">数据库设计的目标</font>"'},"​",-1),R=e("",63),I=s("li",null,"每个表只能定义一个主键",-1),N=s("li",null,"主键的值不能为NULL，必须能够唯一代表一行",-1),w=s("li",null,"复合主键不能包含不必要的多余列",-1),L=e("",4),V=s("li",null,"非空：not null",-1),M=e("",5),X=e("",26),Y=s("li",null,[i("0级封锁 "),s("ul",null,[s("li",null,"封锁的事务不重写其他非0级封锁事务的未提交的更新数据。这种状态实际上实用价值不大。")])],-1),O=s("h2",{id:"_3级封锁",tabindex:"-1"},[i("3级封锁 "),s("a",{class:"header-anchor",href:"#_3级封锁","aria-label":'Permalink to "3级封锁"'},"​")],-1),U=s("p",null,[s("strong",null,"活锁 & 死锁")],-1),Q=s("ul",null,[s("li",null,"排队，如“先到先服务”")],-1),G=s("ul",null,[s("li",null,"一次性锁请求"),s("li",null,"锁请求排序"),s("li",null,"序列化处理"),s("li",null,"资源剥夺")],-1),K=e("",33),H={id:"过程",tabindex:"-1"},z=s("a",{class:"header-anchor",href:"#过程","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">过程</font>"'},"​",-1),Z=e("",6);function $(W,j,J,ss,is,as){const a=t("font");return k(),p("div",null,[d,s("ul",null,[s("li",null,[i("数据（Data）是描述"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("事物的符号记录")]),_:1}),i("，是指用物理符号记录下来的、可以鉴别的信息")]),s("li",null,[i("数据库（DB）是长期存储在计算机中的有组织的、可共享的数据集合，数据库中存储的数据具有"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i(" 永久存储、有组织和可共享")]),_:1}),i("三个基本特点")]),E]),c,s("ul",null,[s("li",null,[i("模式：（"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("概念模式或逻辑模式")]),_:1}),i("），它是数据库中全体数据的逻辑结构或特征的描述，是所有用户的公共数据视图。一个数据库只有一个模式，且相对稳定")]),s("li",null,[i("外模式：（"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("子模式或用户模式")]),_:1}),i(" ），它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是与某一应用有关的数据的逻辑表示 "),o]),s("li",null,[i("内模式：（"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("存储模式")]),_:1}),i("）是对数据库中数据"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i(" 物理结构和存储方式")]),_:1}),i("的描述，是数据在数据库内部的表示形式")])]),g,s("ul",null,[s("li",null,[i("数据结构：描述系统的"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("静态特性")]),_:1}),i("，即数据对象的数据类型、内容、属性及数据对象之间的联系")]),s("li",null,[i("数据操作：描述系统的"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("动态特性")]),_:1}),i("，是对各种对象实例允许执行的操作集合，包括操作及有关的操作规则")]),s("li",null,[i("数据约束：描述数据结构中数据间的"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("语法和语义关联")]),_:1}),i(" ，包括相互制约与依存关系及数据动态变化规则，以保证数据的正确性、有效性和相容性")])]),u,s("ul",null,[y,b,s("li",null,[l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("关系模型")]),_:1})]),F]),m,s("h4",A,[s("strong",null,[l(a,{style:{color:"rgb(0,0,0)"}},{default:n(()=>[i("关系数据语言的分类 ")]),_:1})]),i(),_]),D,s("ul",null,[s("li",null,[i("代数方式主要是"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("关系代数")]),_:1}),i("，通过对关系的操作来表达查询要求的方式")]),s("li",null,[i("逻辑方式主要是"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("关系演算")]),_:1}),i("，使用谓词来表达查询要求的方式")])]),C,s("h4",q,[s("strong",null,[l(a,{style:{color:"rgb(0,0,0)"}},{default:n(()=>[i("函数依赖与关键字")]),_:1})]),i(),f]),x,s("h4",P,[s("strong",null,[l(a,{style:{color:"rgb(0,0,0)"}},{default:n(()=>[i("范式与关系范式化")]),_:1})]),i(),B]),T,s("h4",v,[l(a,{style:{color:"rgb(0,0,0)"}},{default:n(()=>[i("数据库设计的目标")]),_:1}),i(),S]),R,s("ul",null,[s("li",null,[i("主键约束 "),s("ul",null,[I,N,w,s("li",null,[i("一个列名在复合主键的列表中只能出现一次，使用"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i(" promary key")]),_:1}),i(" 标识")])])]),s("li",null,[i("侯选键约束 "),s("ul",null,[s("li",null,[i("使用关键字 "),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("unique")]),_:1}),i(" 定义")])])])]),L,s("ul",null,[V,s("li",null,[i("check 约束："),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("check(c_age>=18) ")]),_:1}),i("表示该列的值大于等于 18")])]),M,s("p",null,[i("触发器是用户定义在"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("关系表")]),_:1}),i("上的一类由事件驱动的数据库对象，也是一种保证数据完整性的方法")]),X,s("ul",null,[Y,s("li",null,[i("1级封锁 "),s("ul",null,[s("li",null,[i("被封锁的事务不允许重写未提交的更新数据。这防止了"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("丢失更新")]),_:1}),i("的发生")])])]),s("li",null,[i("2级封锁 "),s("ul",null,[s("li",null,[i("被封锁的事务既不重写也不读未提交的更新数据。这除了1级封锁的效果外还防止了"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i(" 读脏数据")]),_:1})])])]),s("li",null,[O,i(" 被封锁的事务不读未提交的更新数据，不写任何（包括读操作的）未提交数据。这里除了包含2级封锁外，还不写未提交的读数据，因而防止了"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i(" 不可重复读")]),_:1}),i("的问题")])]),U,s("ul",null,[s("li",null,[i("活锁：因"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("优先级别低")]),_:1}),i("而永远等待下去 "),Q]),s("li",null,[i("死锁：两个以上事务"),l(a,{style:{color:"#DF2A3F"}},{default:n(()=>[i("循环等待")]),_:1}),i("被同组中另一事务锁住的数据单元的情形 "),G])]),K,s("h4",H,[l(a,{style:{color:"rgb(0,0,0)"}},{default:n(()=>[i("过程")]),_:1}),i(),z]),Z])}const es=h(r,[["render",$]]);export{ns as __pageData,es as default};
