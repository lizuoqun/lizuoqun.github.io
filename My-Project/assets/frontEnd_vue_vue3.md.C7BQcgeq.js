import{_ as e,c as a,o as i,aS as l}from"./chunks/framework.nU6VANjp.js";const p=JSON.parse('{"title":"vue3","description":"","frontmatter":{},"headers":[],"relativePath":"frontEnd/vue/vue3.md","filePath":"frontEnd/vue/vue3.md","lastUpdated":1749030379000}'),t={name:"frontEnd/vue/vue3.md"},r=l('<h1 id="vue3" tabindex="-1">vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;vue3&quot;">​</a></h1><h2 id="vue3和vue2的区别" tabindex="-1">vue3和vue2的区别 <a class="header-anchor" href="#vue3和vue2的区别" aria-label="Permalink to &quot;vue3和vue2的区别&quot;">​</a></h2><ul><li>双向数据绑定的原理不同</li><li>是否支持碎片</li><li>API不同</li><li>定义数据变量方法不同</li><li>生命周期的不同</li><li>传值不同</li><li>指令和插槽不同</li><li>main.js不同</li></ul><h2 id="vue3的性能为什么比vue2好" tabindex="-1">vue3的性能为什么比vue2好？ <a class="header-anchor" href="#vue3的性能为什么比vue2好" aria-label="Permalink to &quot;vue3的性能为什么比vue2好？&quot;">​</a></h2><ul><li>diff算法的优化</li><li>静态提升</li><li>事件侦听缓存</li></ul><h2 id="vue3为什么使用proxy" tabindex="-1">vue3为什么使用Proxy <a class="header-anchor" href="#vue3为什么使用proxy" aria-label="Permalink to &quot;vue3为什么使用Proxy&quot;">​</a></h2><ul><li>proxy可以代理整个对象，defineproperty只代理对象上的某个属性</li><li>proxy对代理对象的监听更加丰富</li><li>proxy代理对象会生成新的对象，不会修改被代理对象本身</li><li>proxy补兼容ie浏览器</li></ul>',7),u=[r];function o(n,v,d,s,c,_){return i(),a("div",null,u)}const f=e(t,[["render",o]]);export{p as __pageData,f as default};
