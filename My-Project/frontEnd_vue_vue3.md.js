import{_ as a,c as i,o as l,aP as r}from"./framework.js";const h=JSON.parse('{"title":"vue3","description":"","frontmatter":{},"headers":[],"relativePath":"frontEnd/vue/vue3.md","filePath":"frontEnd/vue/vue3.md","lastUpdated":1758522919000}'),t={name:"frontEnd/vue/vue3.md"};function u(o,e,n,v,d,c){return l(),i("div",null,e[0]||(e[0]=[r('<h1 id="vue3" tabindex="-1">vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;vue3&quot;">​</a></h1><h2 id="vue3和vue2的区别" tabindex="-1">vue3和vue2的区别 <a class="header-anchor" href="#vue3和vue2的区别" aria-label="Permalink to &quot;vue3和vue2的区别&quot;">​</a></h2><ul><li>双向数据绑定的原理不同</li><li>是否支持碎片</li><li>API不同</li><li>定义数据变量方法不同</li><li>生命周期的不同</li><li>传值不同</li><li>指令和插槽不同</li><li>main.js不同</li></ul><h2 id="vue3的性能为什么比vue2好" tabindex="-1">vue3的性能为什么比vue2好？ <a class="header-anchor" href="#vue3的性能为什么比vue2好" aria-label="Permalink to &quot;vue3的性能为什么比vue2好？&quot;">​</a></h2><ul><li>diff算法的优化</li><li>静态提升</li><li>事件侦听缓存</li></ul><h2 id="vue3为什么使用proxy" tabindex="-1">vue3为什么使用Proxy <a class="header-anchor" href="#vue3为什么使用proxy" aria-label="Permalink to &quot;vue3为什么使用Proxy&quot;">​</a></h2><ul><li>proxy可以代理整个对象，defineProperty只代理对象上的某个属性</li><li>proxy对代理对象的监听更加丰富</li><li>proxy代理对象会生成新的对象，不会修改被代理对象本身</li><li>proxy补兼容ie浏览器</li></ul><h2 id="reactive-解构" tabindex="-1">reactive+解构 <a class="header-anchor" href="#reactive-解构" aria-label="Permalink to &quot;reactive+解构&quot;">​</a></h2><p>用es6解构reactive对象得到的是原始值的副本，脱离了响应式系统，因此后续修改不会触发视图更新。Vue3的Proxy只能拦截对对象属性的访问和修改，结构时是浅拷贝、而不是引用拷贝。</p><ul><li>不要解构，直接使用响应式对象属性</li><li>toRefs转成ref对象</li><li>用ref，而不是reactive</li></ul><h2 id="数组更新" tabindex="-1">数组更新 <a class="header-anchor" href="#数组更新" aria-label="Permalink to &quot;数组更新&quot;">​</a></h2><p>可以用<code>a[1] = 999</code>，但是为什么还推荐使用<code>a.splice(1, 1, 999)</code></p><ul><li>vue2迁移项目，vue2中不能通过索引更新</li><li>splice 是原子操作，Vue 可以更好地批量收集依赖和触发更新</li></ul>',13)]))}const p=a(t,[["render",u]]);export{h as __pageData,p as default};
